#include <pbr.hpp>
#include <frustum.hpp>

#include <rlgl.h>
#include <raymath.h>

void DrawModelPBR(ModelEx model, Vector3 position, float scale, Color tint)
{
    Vector3 vScale = { scale, scale, scale };
    Vector3 rotationAxis = { 0.0f, 1.0f, 0.0f };

    DrawModelPBREx(model, position, rotationAxis, 0.0f, vScale, tint);
}

void DrawModelPBREx(ModelEx model, Vector3 position, Vector3 rotationAxis, float rotationAngle, Vector3 scale, Color tint)
{
    // Calculate transformation matrix from function parameters
    // Get transform matrix (rotation -> scale -> translation)
    Matrix matScale = MatrixScale(scale.x, scale.y, scale.z);
    Matrix matRotation = MatrixRotate(rotationAxis, rotationAngle*DEG2RAD);
    Matrix matTranslation = MatrixTranslate(position.x, position.y, position.z);

    Matrix matTransform = MatrixMultiply(MatrixMultiply(matScale, matRotation), matTranslation);

    // Combine model transformation matrix (model.transform) with matrix generated by function parameters (matTransform)
    model.GetModel().transform = MatrixMultiply(model.GetModel().transform, matTransform);

    for(int i = 0; i < model.GetModel().meshCount; i++){
        Vector3 min = model.GetMeshBB(i).min;
        Vector3 max = model.GetMeshBB(i).max;

        max = Vector3Transform(max, model.GetModel().transform);
        min = Vector3Transform(min, model.GetModel().transform);

        if(AABBInFrustum(g_Frustum, min, max)){
            DrawMeshPBR(model.GetModel().meshes[i], model.GetModel().materials[model.GetModel().meshMaterial[i]], model.GetModel().transform);
            
            #ifdef DEBUG
                drawn++;
            #endif
        }

        #ifdef DEBUG
            else{
                culled++;
            }
        #endif
    }
}

void DrawMeshPBR(Mesh mesh, Material material, Matrix transform)
{
    rlEnableShader(material.shader.id);

    int slot = 0;
    rlActiveTextureSlot(slot);
    rlEnableTexture(material.maps[MATERIAL_MAP_ALBEDO].texture.id);
    rlSetUniform(GetShaderLocation(material.shader, "albedoMap"), &slot, SHADER_UNIFORM_SAMPLER2D, 1);
    slot++;

    rlActiveTextureSlot(slot);
    rlEnableTexture(material.maps[MATERIAL_MAP_NORMAL].texture.id);
    rlSetUniform(GetShaderLocation(material.shader, "normalMap"), &slot, SHADER_UNIFORM_SAMPLER2D, 1);
    slot++;
    
    rlActiveTextureSlot(slot);
    rlEnableTexture(material.maps[MATERIAL_MAP_METALNESS].texture.id);
    rlSetUniform(GetShaderLocation(material.shader, "metallicMap"), &slot, SHADER_UNIFORM_SAMPLER2D, 1);
    slot++;
    
    rlActiveTextureSlot(slot);
    rlEnableTexture(material.maps[MATERIAL_MAP_ROUGHNESS].texture.id);
    rlSetUniform(GetShaderLocation(material.shader, "roughnessMap"), &slot, SHADER_UNIFORM_SAMPLER2D, 1);
    slot++;
    
    rlActiveTextureSlot(slot);
    rlEnableTexture(material.maps[MATERIAL_MAP_OCCLUSION].texture.id);
    rlSetUniform(GetShaderLocation(material.shader, "aoMap"), &slot, SHADER_UNIFORM_SAMPLER2D, 1);

    // Get a copy of current matrices to work with,
    // just in case stereo render is required, and we need to modify them
    // NOTE: At this point the modelview matrix just contains the view matrix (camera)
    // That's because BeginMode3D() sets it and there is no model-drawing function
    // that modifies it, all use rlPushMatrix() and rlPopMatrix()
    Matrix matModel = MatrixIdentity();
    Matrix matView = rlGetMatrixModelview();
    Matrix matModelView = MatrixIdentity();
    Matrix matProjection = rlGetMatrixProjection();

    rlSetUniformMatrix(GetShaderLocation(material.shader, "view"), matView);
    rlSetUniformMatrix(GetShaderLocation(material.shader, "projection"), matProjection);

    // Accumulate several model transformations:
    //    transform: model transformation provided (includes DrawModel() params combined with model.transform)
    //    rlGetMatrixTransform(): rlgl internal transform matrix due to push/pop matrix stack
    matModel = MatrixMultiply(transform, rlGetMatrixTransform());

    rlSetUniformMatrix(GetShaderLocation(material.shader, "model"), matModel);

    // Try binding vertex array objects (VAO) or use VBOs if not possible
    // WARNING: UploadMesh() enables all vertex attributes available in mesh and sets default attribute values
    // for shader expected vertex attributes that are not provided by the mesh (i.e. colors)
    // This could be a dangerous approach because different meshes with different shaders can enable/disable some attributes
    if (!rlEnableVertexArray(mesh.vaoId))
    {
        // Bind mesh VBO data: vertex position (shader-location = 0)
        rlEnableVertexBuffer(mesh.vboId[0]);
        rlSetVertexAttribute(material.shader.locs[SHADER_LOC_VERTEX_POSITION], 3, RL_FLOAT, 0, 0, 0);
        rlEnableVertexAttribute(material.shader.locs[SHADER_LOC_VERTEX_POSITION]);

        // Bind mesh VBO data: vertex texcoords (shader-location = 1)
        rlEnableVertexBuffer(mesh.vboId[1]);
        rlSetVertexAttribute(material.shader.locs[SHADER_LOC_VERTEX_TEXCOORD01], 2, RL_FLOAT, 0, 0, 0);
        rlEnableVertexAttribute(material.shader.locs[SHADER_LOC_VERTEX_TEXCOORD01]);

        if (material.shader.locs[SHADER_LOC_VERTEX_NORMAL] != -1)
        {
            // Bind mesh VBO data: vertex normals (shader-location = 2)
            rlEnableVertexBuffer(mesh.vboId[2]);
            rlSetVertexAttribute(material.shader.locs[SHADER_LOC_VERTEX_NORMAL], 3, RL_FLOAT, 0, 0, 0);
            rlEnableVertexAttribute(material.shader.locs[SHADER_LOC_VERTEX_NORMAL]);
        }

        // Bind mesh VBO data: vertex tangents (shader-location = 3, if available)
        if (material.shader.locs[SHADER_LOC_VERTEX_TANGENT] != -1)
        {
            rlEnableVertexBuffer(mesh.vboId[3]);
            rlSetVertexAttribute(material.shader.locs[SHADER_LOC_VERTEX_TANGENT], 4, RL_FLOAT, 0, 0, 0);
            rlEnableVertexAttribute(material.shader.locs[SHADER_LOC_VERTEX_TANGENT]);
        }
    }

    int eyeCount = 1;
    if (rlIsStereoRenderEnabled()) eyeCount = 2;

    for (int eye = 0; eye < eyeCount; eye++)
    {
        // Calculate model-view-projection matrix (MVP)
        Matrix matModelViewProjection = MatrixIdentity();
        if (eyeCount == 1) matModelViewProjection = MatrixMultiply(matModelView, matProjection);
        else
        {
            // Setup current eye viewport (half screen width)
            rlViewport(eye*rlGetFramebufferWidth()/2, 0, rlGetFramebufferWidth()/2, rlGetFramebufferHeight());
            matModelViewProjection = MatrixMultiply(MatrixMultiply(matModelView, rlGetMatrixViewOffsetStereo(eye)), rlGetMatrixProjectionStereo(eye));
        }

        // Send combined model-view-projection matrix to shader
        rlSetUniformMatrix(material.shader.locs[SHADER_LOC_MATRIX_MVP], matModelViewProjection);

        // Draw mesh
        if (mesh.indices != nullptr) rlDrawVertexArrayElements(0, mesh.triangleCount*3, 0);
        else rlDrawVertexArray(0, mesh.vertexCount);
    }

    // Disable all possible vertex array objects (or VBOs)
    rlDisableVertexArray();
    rlDisableVertexBuffer();
    rlDisableVertexBufferElement();

    // Disable shader program
    rlDisableShader();

    // Restore rlgl internal modelview and projection matrices
    rlSetMatrixModelview(matView);
    rlSetMatrixProjection(matProjection);
}